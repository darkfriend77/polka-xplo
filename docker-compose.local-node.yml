# Docker Compose override for co-located full-node / collator deployment
#
# Use this when the indexer runs on the SAME server as a Substrate node
# (validator, collator, or archive node) with a local RPC endpoint.
#
# Usage:
#   docker compose -f docker-compose.yml -f docker-compose.local-node.yml up -d
#
# Combined with a chain override (e.g. Ajuna on a local collator):
#   docker compose \
#     -f docker-compose.yml \
#     -f docker-compose.ajuna.yml \
#     -f docker-compose.local-node.yml \
#     up -d
#
# How it works:
#   LOCAL_NODE_URL is prepended to the RPC pool. The latency-weighted
#   router will naturally send most traffic to it (sub-ms latency vs
#   50-200 ms for public RPCs). Public RPCs in ARCHIVE_NODE_URL serve
#   as automatic fallback if the local node is temporarily unreachable.
#
# Prerequisites:
#   - Your Substrate node must expose its RPC on a port accessible from
#     the Docker container. The default Substrate RPC port is 9944,
#     but collators often remap it (e.g. 9733 for Ajuna).
#     Verify with: curl -s -d '{"jsonrpc":"2.0","id":1,"method":"system_health","params":[]}' \
#                       -H "Content-Type: application/json" http://127.0.0.1:<port>
#   - The node's RPC port must be mapped to the host (e.g. -p 9733:9733)
#     so containers can reach it via host.docker.internal.
#
# Networking:
#   Uses extra_hosts to map "host.docker.internal" to the Docker host
#   gateway. This keeps Docker DNS working between containers (unlike
#   network_mode: host) while still reaching the local Substrate node.
#
# Resource limits:
#   When sharing a server with a collator/validator, the node MUST have
#   priority. All explorer containers are capped in CPU, memory, and
#   given low CPU shares / OOM priority so the kernel favours the
#   collator under pressure.
#
#   Adjust the limits below to match your server spec. The defaults
#   assume a 4-8 core / 16-32 GB server where ~50% of resources are
#   reserved for the collator.
#
# Initial backfill warning:
#   During first sync (millions of blocks), heavy RPC traffic to the
#   local node can destabilise block production. It is recommended to
#   comment out LOCAL_NODE_URL (or remove it from .env) during the
#   initial backfill and use public RPCs only. Once synced, add it
#   back — live mode (~1 block/12s) puts negligible load on the node.

services:
  explorer-indexer:
    # extra_hosts lets the container reach the host machine (and the
    # co-located Substrate node) via "host.docker.internal".
    extra_hosts:
      - "host.docker.internal:host-gateway"
    # --- Resource limits (protect the collator) ---
    cpus: ${INDEXER_CPUS:-2.0}
    mem_limit: ${INDEXER_MEM_LIMIT:-4g}
    memswap_limit: ${INDEXER_MEM_LIMIT:-4g}
    cpu_shares: 256          # Lower than default (1024) — collator gets priority
    oom_score_adj: 500       # Kernel kills indexer before collator under OOM
    environment:
      # Local node endpoint — uses host.docker.internal to reach the host.
      # Set to empty string or omit from .env to disable during backfill.
      LOCAL_NODE_URL: ${LOCAL_NODE_URL:-}
      # Lower concurrency to reduce CPU/IO pressure on the collator
      BACKFILL_CONCURRENCY: ${BACKFILL_CONCURRENCY:-4}

  explorer-db:
    # --- Resource limits (protect the collator) ---
    cpus: ${DB_CPUS:-1.5}
    mem_limit: ${DB_MEM_LIMIT:-3g}
    memswap_limit: ${DB_MEM_LIMIT:-3g}
    cpu_shares: 256
    oom_score_adj: 300

  explorer-redis:
    # --- Resource limits (protect the collator) ---
    cpus: ${REDIS_CPUS:-0.5}
    mem_limit: ${REDIS_MEM_LIMIT:-512m}
    memswap_limit: ${REDIS_MEM_LIMIT:-512m}
    cpu_shares: 128
    oom_score_adj: 400

  explorer-web:
    # --- Resource limits (protect the collator) ---
    cpus: ${WEB_CPUS:-1.0}
    mem_limit: ${WEB_MEM_LIMIT:-1g}
    memswap_limit: ${WEB_MEM_LIMIT:-1g}
    cpu_shares: 128
    oom_score_adj: 600       # Least critical — killed first
